<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), clipboard-write=*, display-capture=()">
    <title>AIDesigner</title>
    <script>
        // Block problematic APIs to prevent permission violations
        (function() {
            if (typeof navigator !== 'undefined') {
                // Block camera and microphone APIs
                if (navigator.mediaDevices) {
                    navigator.mediaDevices.getUserMedia = function() {
                        return Promise.reject(new Error('getUserMedia blocked to prevent permission violations'));
                    };
                    navigator.mediaDevices.getDisplayMedia = function() {
                        return Promise.reject(new Error('getDisplayMedia blocked to prevent permission violations'));
                    };
                }
                
                // Preserve clipboard functionality but make it safer
                if (navigator.clipboard) {
                    const originalWriteText = navigator.clipboard.writeText;
                    navigator.clipboard.writeText = function(text) {
                        try {
                            return originalWriteText.call(navigator.clipboard, text);
                        } catch (e) {
                            console.warn('Clipboard access blocked by permissions policy');
                            return Promise.resolve();
                        }
                    };
                }
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            background: #ffffff;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e1e4e8;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            color: #586069;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-btn.active {
            color: #0366d6;
            border-bottom-color: #0366d6;
            background: #ffffff;
        }

        .tab-btn:hover:not(.active) {
            color: #24292e;
            background: #f1f3f4;
        }

        /* Tab Content */
        .tab-content {
            flex: 1;
            display: none;
            padding: 16px;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        /* Common Elements */
        .section {
            margin-bottom: 20px;
        }

        .section h3 {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #24292e;
        }

        .btn {
            background: #0366d6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover:not(:disabled) {
            background: #0256cc;
        }

        .btn:disabled {
            background: #8c959f;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #24292e;
            border: 1px solid #d1d5da;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f8f9fa;
        }

        .btn-pipeline {
            background: #28a745;
            color: white;
            margin-left: 8px;
        }

        .btn-pipeline:hover:not(:disabled) {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            font-size: 11px;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            width: auto;
            margin: 0 4px 0 0;
        }

        .error-box {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 4px;
            padding: 10px;
            margin: 5px 0;
        }

        .warning-box {
            background: #ffc;
            border: 1px solid #fc9;
            border-radius: 4px;
            padding: 10px;
            margin: 5px 0;
        }

        .error-box h4, .warning-box h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            font-weight: 600;
        }

        .error-box ul, .warning-box ul {
            margin: 0;
            padding-left: 16px;
            font-size: 11px;
        }

        .error-box li, .warning-box li {
            margin-bottom: 4px;
        }
        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #24292e;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5da;
            border-radius: 4px;
            font-size: 12px;
            resize: vertical;
        }

        .input-group textarea {
            min-height: 80px;
        }

        /* Status Messages */
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 12px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }


        /* Enhanced Component List */
        .stats-bar {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: #f1f3f4;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 11px;
        }

        .stat {
            color: #586069;
        }

        .stat-value {
            font-weight: 600;
            color: #24292e;
        }

        .filter-bar {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .filter-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #d1d5da;
            border-radius: 3px;
            font-size: 11px;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 1px solid #d1d5da;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            color: #586069;
        }

        .filter-btn.active {
            background: #0366d6;
            color: white;
            border-color: #0366d6;
        }

        .component-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            min-height: 200px;
        }

        .component-item {
            padding: 12px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .component-item:hover {
            background: #f8f9fa;
        }

        .component-item:last-child {
            border-bottom: none;
        }

        .component-info {
            flex: 1;
            min-width: 0;
        }

        .component-name {
            font-weight: 600;
            font-size: 12px;
            color: #24292e;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .component-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .type-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
        }

        .type-select {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #d1d5da;
            border-radius: 3px;
            background: white;
            font-size: 11px;
            color: #586069;
            cursor: pointer;
        }

        .type-select:focus {
            border-color: #0366d6;
            box-shadow: 0 0 0 2px rgba(3, 102, 214, 0.2);
            outline: none;
        }

        .type-select option {
            padding: 4px 8px;
        }

        .confidence-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
            min-width: 35px;
            text-align: center;
        }

        .confidence-high {
            background: #d4edda;
            color: #155724;
        }

        .confidence-medium {
            background: #fff3cd;
            color: #856404;
        }

        .confidence-low {
            background: #f8d7da;
            color: #721c24;
        }

        .confidence-verified {
            background: #d1ecf1;
            color: #0c5460;
        }

        .component-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }

        .btn-action {
            padding: 4px 8px;
            border: 1px solid #d1d5da;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            color: #586069;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background: #f8f9fa;
            border-color: #0366d6;
            color: #0366d6;
        }

        .page-info {
            font-size: 9px;
            color: #959da5;
            margin-left: 8px;
        }

        .status-icon {
            font-size: 10px;
            margin-right: 4px;
        }

        .icon-verified {
            color: #28a745;
        }

        .icon-auto {
            color: #0366d6;
        }

        .icon-unknown {
            color: #d73a49;
        }




        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row .btn {
            margin-bottom: 0;
            flex: 1;
        }

        .scan-status {
            background: #f8f9fa;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .scan-status.loaded {
            background: #d4edda;
            border-color: #c3e6cb;
        }

        .scan-status-text {
            font-size: 11px;
            color: #24292e;
            margin-bottom: 8px;
        }

        .hidden {
            display: none;
        }
        

        .iteration-context {
            border: 1px solid #d1ecf1;
            background: #f1f8ff;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }
        .current-design-info h4 {
            font-size: 12px;
            font-weight: 600;
            color: #0366d6;
            margin: 0 0 8px 0;
        }
        .current-design-info h4 span {
            font-weight: 500;
            color: #24292e;
        }

        /* NEW: Session Modal Styles */
        .session-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .session-modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
        }

        .session-modal-content {
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 360px;
            width: calc(100% - 32px);
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .session-modal-header h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            color: #24292e;
        }

        .session-modal-header p {
            margin: 0 0 16px 0;
            font-size: 12px;
            color: #586069;
        }

        .session-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .session-detail {
            margin-bottom: 8px;
            font-size: 11px;
        }

        .session-detail strong {
            color: #24292e;
            display: inline-block;
            min-width: 80px;
        }

        .session-detail span {
            color: #586069;
        }

        #sessionHistoryList {
            margin: 4px 0 0 0;
            padding-left: 16px;
            font-size: 10px;
            color: #586069;
            max-height: 60px;
            overflow-y: auto;
        }

        #sessionHistoryList li {
            margin-bottom: 2px;
        }

        .session-modal-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .session-modal-actions .btn {
            margin-bottom: 0;
        }

        .session-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .session-item {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .session-item:hover {
            background: #f8f9fa;
            border-color: #0366d6;
        }

        .session-item.current-file {
            border-color: #28a745;
            background: #f1f8ff;
        }

        .session-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .session-file-name {
            font-weight: 600;
            font-size: 12px;
            color: #24292e;
        }

        .session-time {
            font-size: 10px;
            color: #586069;
        }

        .session-item-details {
            font-size: 10px;
            color: #586069;
        }

        .session-item-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .session-item-actions .btn {
            padding: 4px 8px;
            font-size: 10px;
            margin: 0;
            flex: 1;
        }

        .current-file-badge {
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-nav">
        <button class="tab-btn active" onclick="switchTab('design-system')">üîç Design System</button>
        <button class="tab-btn" onclick="switchTab('api-settings')">‚öôÔ∏è API Settings</button>
        <button class="tab-btn" onclick="switchTab('ai-generator')" id="generatorTab" disabled>üí¨ AI Generator</button>
    </div>

    <!-- Session Restoration Modal -->
    <div class="session-modal" id="sessionModal" style="display: none;">
        <div class="session-modal-backdrop" onclick="closeSessionModal()"></div>
        <div class="session-modal-content">
            <div class="session-modal-header">
                <h3>üîÑ Found Previous Work</h3>
                <p>There's unfinished design work in this file</p>
            </div>
            
            <div class="session-modal-body">
                <div class="session-info">
                    <div class="session-detail">
                        <strong>Frame:</strong> <span id="sessionFrameName"></span>
                    </div>
                    <div class="session-detail">
                        <strong>Last modified:</strong> <span id="sessionLastModified"></span>
                    </div>
                    <div class="session-detail">
                        <strong>History:</strong> 
                        <ul id="sessionHistoryList"></ul>
                    </div>
                </div>
            </div>
            
            <div class="session-modal-actions">
                <button class="btn" onclick="restoreSession()">üìÇ Continue Work</button>
                <button class="btn btn-secondary" onclick="startNewSession()">üóÇÔ∏è Start Fresh</button>
                <button class="btn btn-secondary btn-small" onclick="showAllSessions()">üëÅÔ∏è All Sessions</button>
            </div>
        </div>
    </div>

    <!-- All Sessions Modal -->
    <div class="session-modal" id="allSessionsModal" style="display: none;">
        <div class="session-modal-backdrop" onclick="closeAllSessionsModal()"></div>
        <div class="session-modal-content">
            <div class="session-modal-header">
                <h3>üìÅ All Active Sessions</h3>
                <p>Select a session to view or manage</p>
            </div>
            
            <div class="session-modal-body">
                <div class="session-list" id="allSessionsList">
                    <!-- Dynamically generated by JS -->
                </div>
            </div>
            
            <div class="session-modal-actions">
                <button class="btn btn-secondary" onclick="closeAllSessionsModal()">‚ùå Close</button>
            </div>
        </div>
    </div>

    <!-- Tab 1: Design System -->
    <div class="tab-content active" id="design-system">
        <div class="scan-status" id="scanStatusContainer">
            <div class="scan-status-text" id="scanStatusText">No design system scanned yet</div>
            <button class="btn btn-secondary btn-small" onclick="rescanDesignSystem()" id="rescanBtn" style="display: none;">üîÑ Re-scan</button>
        </div>

        <div class="section">
            <h3>Scan Components</h3>
            <div class="button-row">
                <button class="btn" onclick="scanDesignSystem()" id="scanBtn">üîç Scan Design System</button>
                <button class="btn btn-secondary" onclick="exportRawScanData()" id="exportRawBtn" style="display: none;">üì§ Export Raw Data</button>
            </div>
        </div>

        <div class="section" id="componentsSection" style="display: none;">
            <h3>Found Components</h3>
            
            <div class="stats-bar" id="statsBar">
                <div class="stat">Total: <span class="stat-value" id="totalCount">0</span></div>
                <div class="stat">High confidence: <span class="stat-value" id="highConfCount">0</span></div>
                <div class="stat">Need review: <span class="stat-value" id="lowConfCount">0</span></div>
                <div class="stat">Verified: <span class="stat-value" id="verifiedCount">0</span></div>
            </div>

            <div class="filter-bar">
                <input type="text" class="filter-input" placeholder="Search components..." id="searchInput">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="unknown">Unknown</button>
                <button class="filter-btn" data-filter="low">Low Conf</button>
                <button class="filter-btn" data-filter="verified">Verified</button>
            </div>
            
            <div class="component-list" id="componentsList"></div>
        </div>

    </div>

    <!-- Tab 2: API Settings -->
    <div class="tab-content" id="api-settings">
        <div class="section">
            <h3>Gemini API Configuration</h3>
            <div class="input-group">
                <label for="apiKey">API Key:</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key">
            </div>
            <button class="btn" onclick="saveApiKey()" id="saveBtn">üíæ Save API Key</button>
        </div>

        <div class="section">
            <h3>Connection Test</h3>
            <button class="btn btn-secondary" onclick="testGeminiConnection()" id="testBtn">üîå Test Connection</button>
            <div id="connectionStatus"></div>
        </div>

    </div>

    <!-- Tab 3: AI Generator -->
    <div class="tab-content" id="ai-generator">


        <div class="section">
            <div class="input-group">
                <label for="jsonInput">Paste 3-stage pipeline JSON result:</label>
                <textarea id="jsonInput" placeholder="Paste JSON from python3 instance.py alt3 output..." style="height: 100px; font-family: monospace; font-size: 10px;"></textarea>
            </div>
            <button class="btn" onclick="renderFromJSON()" id="jsonRenderBtn">üé® Render JSON</button>
            
            <!-- Validation Feedback -->
            <div id="validation-feedback" style="display: none; margin-top: 10px;">
                <div class="error-box" id="validation-errors" style="display: none;">
                    <h4>Validation Errors:</h4>
                    <ul id="error-list"></ul>
                </div>
                <div class="warning-box" id="validation-warnings" style="display: none;">
                    <h4>Warnings (will auto-fix):</h4>
                    <ul id="warning-list"></ul>
                </div>
                <label style="margin-top: 10px;">
                    <input type="checkbox" id="force-render"> 
                    Force render despite errors
                </label>
            </div>
            
        </div>

        <div id="generationStatus"></div>

        <!-- JSON Debug Section -->
        <div class="section" id="jsonDebugSection" style="display: none;">
            <h3>Generated JSON</h3>
            <div class="button-row">
                <button class="btn btn-secondary btn-small" onclick="copyGeneratedJSON()">üìã Copy JSON</button>
                <button class="btn btn-secondary btn-small" onclick="toggleJSONView()">üëÅÔ∏è Show/Hide</button>
            </div>
            <pre id="jsonOutput" style="display: none; background: #f6f8fa; border: 1px solid #d1d5da; border-radius: 4px; padding: 12px; font-size: 11px; overflow-x: auto; max-height: 300px; overflow-y: auto; font-family: 'Monaco', 'Consolas', monospace;"></pre>
        </div>

    </div>

    <!-- Load pattern intelligence before main script -->
    <script src="component-patterns.js"></script>
    
    <!-- EMBEDDED PROMPT GENERATOR CLASS -->
    <script>
        if(typeof window!=="undefined"&&window.PatternDetector);else if(typeof require!=="undefined"){const{PatternDetector:e}=require("./component-patterns.js")}class AIDesignerPromptGenerator{constructor(){this.basePersonality=this.buildUXExpertPersonality()}generatePrompt(e,t=[],s=[],i=!1){if(i)var n=this.generateImageAnalysisPrompt(e,t);else{const s=this.preprocessForCommonIssues(e),i=this.buildExpertSystemPrompt(t),o=this.generateContextualGuidance(s),r=this.enhanceUserRequest(s,o);var n={systemPrompt:i,userPrompt:r,fullPrompt:`${i}\n\n${r}\n\nRespond ONLY with valid JSON, without any additional text, comments, or markdown.`,guidance:o}}if("undefined"!=typeof PatternDetector){const t=PatternDetector.detect(e);t.length>0&&(n.userPrompt+=PatternDetector.generateGuidance(t,e),n.fullPrompt=`${n.systemPrompt}\n\n${n.userPrompt}\n\nRespond ONLY with valid JSON, without any additional text, comments, or markdown.`)}return n}generateModificationPrompt(e,t,s){const i=this.buildModificationSystemPrompt(t,e,s);return{systemPrompt:"",userPrompt:"",fullPrompt:`${i}\n\nRespond ONLY with valid JSON, without any additional text, comments, or markdown.`,guidance:[]}}buildModificationSystemPrompt(e,t,s){const i=this.analyzeAvailableComponents(s),n=this.buildDesignSystemContext(i);return`You are an expert UX Designer modifying an existing UI design based on a user's request.

## Your Task:
Modify the "CURRENT DESIGN" JSON structure according to the "USER REQUEST". Return the COMPLETE, new JSON structure.

${n}

---

## CURRENT DESIGN:
\`\`\`json
${JSON.stringify(e,null,2)}
\`\`\`

---

## USER REQUEST:
"${t}"

---

## MODIFICATION RULES (MANDATORY):
1.  **Preserve Unchanged Elements:** Keep ALL elements and properties that were not mentioned in the user request exactly as they are in the "CURRENT DESIGN". Do not alter or remove them.
2.  **Maintain Component IDs:** For all unchanged components, you MUST use the same \`componentNodeId\` as in the original JSON.
3.  **Apply Specific Changes:** Only modify, add, or remove the elements and properties that the user explicitly requested.
4.  **Logical Placement:** When adding new items, place them in a logical position relative to other elements.
5.  **Return Full Structure:** Your final output must be the ENTIRE JSON object, including both the modified and the preserved parts.

## üîß VARIANT MODIFICATION RULES:
- **When modifying variants**: Always include the complete variants object with ALL required properties
- **For leading/trailing icons**: Use "Leading": "Icon" and "Trailing": "Icon"
- **For removing icons**: Use "Leading": "None" and "Trailing": "None"  
- **Always validate**: Ensure all variant combinations are complete and valid

## ‚úÖ CORRECT Variant Modification Example:
\`\`\`json
{
  "type": "list-item",
  "componentNodeId": "10:123",
  "properties": {
    "text": "Settings item",
    "horizontalSizing": "FILL",
    "variants": {
      "Condition": "1-line",
      "Leading": "Icon",
      "Trailing": "Icon"
    }
  }
}
\`\`\`

${this.getJSONStructureGuide()}
`}generateImageAnalysisPrompt(e,t){console.log("üñºÔ∏è Generating image analysis prompt.");const s=this.analyzeAvailableComponents(t),i=this.buildDesignSystemContext(s),n=`${this.basePersonality}

## üñºÔ∏è IMAGE ANALYSIS TASK

You are analyzing a UI screenshot, wireframe, or mockup. Your expert UX designer skills allow you to:

1.  **Understand Layout Patterns**: Identify how elements are arranged (vertical stack, horizontal sections, grid, etc.).
2.  **Map UI Components**: Recognize buttons, inputs, cards, text, images, and other common UI elements.
3.  **Read Visual Hierarchy**: Understand what's primary vs. secondary content based on size, position, and emphasis.
4.  **Extract Information Architecture**: See how content is grouped and organized into logical sections.

${i}

## üéØ Your Task:
Analyze the provided user interface image and the user's text request. Your goal is to recreate a similar layout and structure using the available components from the design system.

${this.getJSONStructureGuide()}

## üß† Image Analysis Guidelines:
- Focus on the **LAYOUT, STRUCTURE, and HIERARCHY** of the image, not the exact colors, fonts, or pixel-perfect styling.
- **Map the visual elements** in the image to the most appropriate components available in the design system.
- If the user provides a text prompt, it **overrides or clarifies** the image. For example, if the image shows a "Sign Up" button but the user asks for a "Login" page, you should create a login page.
- Maintain the same **information hierarchy and grouping** you see in the image.
- Use nested \`layoutContainer\`s to represent columns, rows, and grouped sections from the image.
- Infer appropriate **spacing and padding** based on the visual relationships in the image.

${this.getJSONExamples()}

## User's Request:
${e||"Recreate the layout from the provided image."}`;return{systemPrompt:"",userPrompt:"",fullPrompt:`${n}\n\nRespond ONLY with valid JSON, without any additional text, comments, or markdown.`,guidance:[]}}buildExpertSystemPrompt(e){const t=this.analyzeAvailableComponents(e),s=this.buildDesignSystemContext(t);return`${this.basePersonality}

${s}

${this.getJSONStructureGuide()}

${this.getUXPrinciples()}

${this.getJSONExamples(e)}`}buildUXExpertPersonality(){return`You are an experienced Senior UX Designer with 10+ years of experience in creating interfaces for web and mobile applications. You have deep knowledge in:

## Your Expertise:
- **User Experience Design**: You understand user needs and create intuitive interfaces
- **Information Architecture**: You can structure content logically and clearly
- **Interaction Design**: You know how to create smooth and effective interactions
- **Accessibility**: You always consider the needs of users with disabilities
- **Design Systems**: You understand the importance of consistency and scalability
- **Mobile & Responsive Design**: Expert in adaptive and mobile-first approaches
- **Modern UI Patterns**: You know modern trends and best practices (Material Design, Human Interface Guidelines, etc.)

## Your Approach:
- Always ask yourself "Why?" before creating something
- Think about the entire user journey, not just a single screen
- Balance aesthetics with functionality
- Consider technical limitations, but don't let them constrain the UX
- Create interfaces that "breathe" - with proper spacing and hierarchy

## Your Task:
Create structured JSON to generate UI in Figma, using components from the user's design system. Apply your UX knowledge to create logical, user-friendly, and beautiful interfaces.`}preprocessForCommonIssues(e){const t=[];return/upload.*button|button.*upload|form.*file.*submit/i.test(e)&&t.push("Keep submit/send buttons as separate items in the main items array, NOT nested inside upload containers"),/captcha.*button|verification.*submit/i.test(e)&&t.push("CAPTCHA sections and submit buttons must be separate objects in the items array"),t.length>0?e+'\n\n// ‚ö†Ô∏è CRITICAL WARNINGS:\n'+t.map(e=>`// - ${e}`).join("\n"):e}analyzeAvailableComponents(e){if(!e||0===e.length)return{byType:{},isEmpty:!0};const t={},s={};return e.forEach(e=>{e.confidence>=.7||e.isVerified?(t[e.suggestedType]||(t[e.suggestedType]=[]),t[e.suggestedType].push(e),s[e.suggestedType]={hasVariants:!(!e.variants||!e.variants.length>0),hasTextLayers:!(!e.textLayers||!e.textLayers.length>0),variants:e.variants||[],variantDetails:e.variantDetails||{},textLayers:e.textLayers||[]}):void 0}),{byType:t,capabilities:s,totalCount:Object.keys(t).length,isEmpty:!1}}buildDesignSystemContext(e){if(e.isEmpty)return`## Available Components:
*Design system not loaded. Please scan your design system first.*
    
IMPORTANT: You cannot use placeholder IDs. Each component must have a real componentNodeId from the scanned design system.`;let t=`## Your Design System (${e.totalCount} component types):
    
*As a Senior UX Designer, you understand that this design system is your tool for creating a consistent experience. Use components wisely, considering their purpose and capabilities.*
    
**CRITICAL**: You MUST use the exact componentNodeId values provided below. Do NOT use placeholder IDs like "button_id" or "input_id_1".
    
`;const s=this.groupComponentsByUXPurpose(e.byType);return Object.entries(s).forEach(([s,i])=>{if(i.length>0){t+=`### ${s}\n`,i.forEach(s=>{const i=e.capabilities[s.suggestedType];t+=`- **${s.suggestedType}** ‚Üí Use componentNodeId: "${s.id}"`,i?.variantDetails&&Object.keys(i.variantDetails).length>0?(t+="\n  - Variants available:\n",Object.entries(i.variantDetails).forEach(([e,s])=>{t+=`    - ${e}: [${s.map(e=>`"${e}"`).join(", ")}]\n`;const i=e.toLowerCase();i.includes("condition")||i.includes("layout")?t+=`      üí° Layout control: ${s.includes("1-line")?'"1-line" = single line, ':""}${s.includes("2-line")?'"2-line" = detailed view':""}\n`:i.includes("leading")||i.includes("start")?t+="      üí° Leading element: \"Icon\" = shows leading icon, \"None\" = text only\n":i.includes("trailing")||i.includes("end")?t+="      üí° Trailing element: \"Icon\" = shows trailing icon/chevron, \"None\" = no trailing element\n":i.includes("state")||i.includes("status")?t+="      üí° Component state: controls enabled/disabled/selected appearance\n":i.includes("size")?t+="      üí° Size control: affects padding, text size, and touch targets\n":(i.includes("type")||i.includes("style")||i.includes("emphasis"))&&(t+="      üí° Visual emphasis: controls hierarchy and visual weight\n")}),t+="\n  - ‚ö° QUICK VARIANT GUIDE:\n",t+='    - "single line" request ‚Üí use "Condition": "1-line"\n',t+='    - "with icon" request ‚Üí use "Leading": "Icon"\n',t+='    - "arrow" or "chevron" ‚Üí use "Trailing": "Icon"\n',t+='    - "simple" or "minimal" ‚Üí omit variants to use defaults\n',t+="    - Only specify variants you want to change from defaults\n"):i?.hasVariants&&(t+=` - Variants: ${i.variants.join(", ")}`),i?.hasTextLayers&&(t+=`  - Text layers: ${i.textLayers.map(e=>`"${e}"`).join(", ")}`),t+="\n"}),t+="\n"}}),t+=`**Remember**: Always use the exact componentNodeId values listed above. Never use placeholder IDs.

## ‚úÖ CORRECT JSON Example (List Item):
\`\`\`json
{
  "layoutContainer": { "name": "Settings", "layoutMode": "VERTICAL", "width": 360, "itemSpacing": 8 },
  "items": [
    { 
      "type": "list-item", 
      "componentNodeId": "${this.getExampleId(e,"list-item")}", 
      "properties": {
        "text": "Change language",
        "supporting-text": "Select your preferred language",
        "trailing-text": "English",
        "horizontalSizing": "FILL"
      } 
    }
  ]
}
\`\`\`

## üéØ Property Name Guidelines:
- **Main content**: Use \`"text"\` or \`"headline"\`
- **Secondary content**: Use \`"supporting-text"\` or \`"subtitle"\`  
- **End content**: Use \`"trailing-text"\` or \`"value"\`
- **Never use**: Property names with spaces unless they match exact text layer names
    
## ‚ùå WRONG - Never use these:
- "input_id", "input_id_1", "button_id" (placeholder IDs)
- "component_123" (made-up IDs)`,t}groupComponentsByUXPurpose(e){const t={"üéØ User Actions":[],"üìù Data Input":[],"üß≠ Navigation":[],"üìã Content Display":[],"üí¨ Feedback":[],"üìê Page Structure":[]},s={"üéØ User Actions":["button","fab","chip","link","icon-button"],"üìù Data Input":["input","textarea","select","checkbox","radio","switch","slider","searchbar","form","upload"],"üß≠ Navigation":["appbar","tab","tabs","breadcrumb","pagination","navigation","sidebar","menu"],"üìã Content Display":["card","list","list-item","avatar","image","text","header","badge","icon"],"üí¨ Feedback":["snackbar","alert","dialog","modal","progress","skeleton","tooltip"],"üìê Page Structure":["container","grid","divider","spacer","frame"]};return Object.entries(e).forEach(([e,i])=>{let n=!1;for(const[o,r]of Object.entries(s))if(r.includes(e)){t[o].push(...i),n=!0;break}n||t["üìê Page Structure"].push(...i)}),t}generateContextualGuidance(e){const t=[],s=e.toLowerCase();return this.containsKeywords(s,["form","login","register","signin","password","email"])&&t.push("Forms should be simple and clear. Place required fields first, and group related fields."),this.containsKeywords(s,["navigat","menu","tab","section"])&&t.push("Navigation should be intuitive. No more than 7¬±2 items per level. Indicate the current location."),this.containsKeywords(s,["list","card","item","product"])&&t.push("Lists should have a scannable structure: important information at the top, secondary at the bottom. Ensure sufficient spacing between items."),this.containsKeywords(s,["mobile","phone","adaptive","responsive"])&&t.push("Mobile-first approach: large touch targets (min. 44px), easy thumb access, vertical orientation."),this.containsKeywords(s,["dashboard","panel","stat","analytic"])&&t.push("Dashboards: most important information at the top and left, use progressive disclosure for details."),this.containsKeywords(s,["settings","preferences","account","options","configure"])&&(t.push("Settings screens should show current values for quick reference. Use 'trailing-text' to display current language, phone number, email, notification status, etc."),t.push("Group related settings logically. Show action hints like 'What is it?' for premium features, current values for user data.")),this.containsKeywords(s,["single line","one line","1 line","minimal","simple"])&&t.push('For single line layouts, use "Condition": "1-line" variant.'),this.containsKeywords(s,["two line","double line","2 line","detailed"])&&t.push('For two line layouts, use "Condition": "2-line" variant.'),this.containsKeywords(s,["with icon","show icon","icon before"])&&t.push('To show leading icons, use "Leading": "Icon" variant.'),this.containsKeywords(s,["no icon","without icon","text only"])&&t.push('To hide icons, use "Leading": "None" variant.'),this.containsKeywords(s,["trailing","end icon","arrow","chevron"])&&t.push('To show trailing elements, use "Trailing": "Icon" variant.'),t}enhanceUserRequest(e,t){let s=e;return t.length>0&&(s+="\n\n// As an experienced UX designer, consider these principles:",t.forEach(e=>{s+=`\n// - ${e}`})),s+="\n\n// Apply your UX knowledge to create a logical, user-friendly, and aesthetically pleasing interface.",s}getUXPrinciples(){return`## Your UX Principles (always follow them):

### 1. Hierarchy and Importance
- The most important elements are the largest and highest
- Use size, color, and position to create a visual hierarchy
- The primary action (Primary CTA) must be obvious

### 2. Spacing and Breathing Room
- Use consistent spacing: 8px, 16px, 24px, 32px
- Let the content "breathe" - don't cram everything onto one screen
- Group related elements through proximity

### 3. Cognitive Load
- Don't overload the user with options
- Progressive disclosure: show the main things, hide the details
- Make the next steps obvious

### 4. Accessibility
- Minimum touch target size: 44px
- Sufficient contrast for text
- Logical tabbing order

### 5. User Mental Models
- Use familiar patterns (don't reinvent the wheel)
- Place elements where they are expected
- Consistency throughout the entire product`}getJSONStructureGuide(){return`## JSON Structure & Rules:

### Basic structure:
\`\`\`json
{
  "layoutContainer": {
    "name": "Container Name",
    "layoutMode": "VERTICAL",
    "width": 360,           // Always specify width for mobile
    "paddingTop": 24,
    "paddingBottom": 24,
    "paddingLeft": 16,
    "paddingRight": 16,
    "itemSpacing": 16
  },
  "items": [
    // ... components go here
  ]
}
\`\`\`

### UX Considerations for JSON:
- **layoutMode**: VERTICAL is easier to scan for most content.
- **itemSpacing**: Use 16px for related items, 24px+ for separating sections.
- **horizontalSizing**: "FILL" is crucial for primary actions (buttons) and inputs.
- **items order**: This defines the visual and accessibility order. Top-to-bottom matters.

### Component Selection Rules:
- **ALWAYS use the exact componentNodeId from the design system list above**
- Never use placeholder IDs like "button_id", "input_id", etc.
- File upload areas: Use layoutContainer with icon + text, NOT image component
- Secondary buttons: Use button with variants like "Medium" emphasis
- CAPTCHA/forms: Use input or form components, NOT list-item
- All form inputs: Must have horizontalSizing: "FILL"
- Icon actions: Use icon-button if available, or button with icon property

### Text Property Rules:
- **Primary text**: Use \`"text"\` or \`"headline"\` for main content
- **Secondary text**: Use \`"supporting-text"\` for descriptions
- **Action/Value text**: Use \`"trailing-text"\` for status, values, or action hints
- **Property names should be lowercase with hyphens**: \`"supporting-text"\` not \`"Supporting text"\`
- **Avoid variant names as text content**: Don't use \`"Headline": "text content"\`

### Enhanced List Item Example:
\`\`\`json
{
  "type": "list-item",
  "componentNodeId": "10:123",
  "properties": {
    "text": "Change language",           // Main headline
    "supporting-text": "Select your preferred language",  // Optional description
    "trailing-text": "English",   // Current value or action hint
    "horizontalSizing": "FILL",
    "variants": {
      "Condition": "1-line",       // Component variants in separate object
      "Leading": "Icon",
      "Trailing": "Icon"
    }
  }
}
\`\`\`

### Variant Usage Rules:
- **Variants must be in a separate "variants" object inside properties**
- **NEVER mix variants with regular properties at the same level**
- Variant properties are case-sensitive: "Condition" not "condition"
- Variant values are case-sensitive: "1-line" not "1-Line"

### ‚úÖ CORRECT Variant Structure:
\`\`\`json
{
  "type": "list-item",
  "componentNodeId": "10:123",
  "properties": {
    "text": "Personal details",
    "horizontalSizing": "FILL",
    "variants": {
      "Condition": "1-line",
      "Leading": "Icon", 
      "Trailing": "Icon"
    }
  }
}
\`\`\`

### ‚ùå WRONG - Never do this:
\`\`\`json
{
  "properties": {
    "text": "Personal details",
    "Condition": "1-line",    // WRONG: variants mixed with properties
    "Leading": "Icon"         // WRONG: should be in variants object
  }
}
\`\`\`

### Example with variants:
\`\`\`json
{
  "type": "button",
  "componentNodeId": "10:123",
  "properties": {
    "text": "Submit",
    "horizontalSizing": "FILL",
    "variants": {
      "Type": "Primary",    // Must match exactly from available options
      "Size": "Large",      // Case-sensitive!
      "State": "enabled"    // Default states are usually "enabled" or "default"
    }
  }
}
\`\`\`

### Button Hierarchy:
- Primary actions (Submit, Send): "High" emphasis, horizontalSizing: "FILL"
- Secondary actions (Add more): "Medium" emphasis, horizontalSizing: "AUTO"
- Icon actions: icon-button or button with icon

### CRITICAL OBJECT SEPARATION RULES:
Each item in the "items" array must be a complete, separate object.

‚úÖ CORRECT - Separate objects:
\`\`\`json
{
  "items": [
    { 
      "type": "layoutContainer",
      "name": "Section1",
      "items": []
    },
    { 
      "type": "button",
      "componentNodeId": "10:3907",  // Real ID from design system
      "properties": {}
    }
  ]
}
\`\`\`

‚ùå WRONG - Placeholder IDs:
\`\`\`json
{
  "items": [
    { 
      "type": "button",
      "componentNodeId": "button_id",  // NEVER use placeholder IDs!
      "properties": {}
    }
  ]
}
\`\`\``}getJSONExamples(e){const t=t=>{if(!e||!e.byType||e.isEmpty)return`${t}_actual_id`;const s=e.byType[t];return s&&Array.isArray(s)&&s.length>0?s[0].id:`${t}_actual_id`},s=t("header"),i=t("input"),n=t("button"),o=t("text"),r=t("image"),a=t("list-item");return`## Examples (with UX rationale):

### Login Form (classic user flow):
\`\`\`json
{
  "layoutContainer": {
    "name": "Login Form",
    "layoutMode": "VERTICAL",
    "width": 360,
    "paddingTop": 32,
    "paddingBottom": 32,
    "paddingLeft": 24,
    "paddingRight": 24,
    "itemSpacing": 20
  },
  "items": [
    { "type": "header", "componentNodeId": "${s}", "properties": {"text": "Sign In"} },
    { "type": "input", "componentNodeId": "${i}", "properties": {"text": "Email", "horizontalSizing": "FILL"} },
    { "type": "input", "componentNodeId": "${i}", "properties": {"text": "Password", "horizontalSizing": "FILL"} },
    { 
    "type": "button", 
    "componentNodeId": "${n}", 
    "properties": {
        "text": "Sign In", 
        "horizontalSizing": "FILL",
        "variants": {
            "State": "enabled",
            "Style": "selected"
        }
    } 
}
  ]
}
\`\`\`
*UX decision: A title for context, full-width inputs for easy tapping, and the primary action button at the bottom for a natural flow.*

### Complex Form with File Upload and Submit Button:
\`\`\`json
{
  "layoutContainer": {
    "name": "Upload Form",
    "layoutMode": "VERTICAL",
    "width": 360,
    "paddingTop": 24,
    "paddingBottom": 24,
    "paddingLeft": 16,
    "paddingRight": 16,
    "itemSpacing": 16
  },
  "items": [
    { "type": "header", "componentNodeId": "${s}", "properties": {"text": "Upload Documents"} },
    {
      "type": "layoutContainer",
      "name": "FileUploadSection",
      "items": [
        { "type": "text", "componentNodeId": "${o}", "properties": {"text": "Upload your file"} },
        { "type": "image", "componentNodeId": "${r}", "properties": {"icon": "upload"} }
      ]
    },
    {
      "type": "layoutContainer",
      "name": "CaptchaSection",
      "items": [
        { "type": "text", "componentNodeId": "${o}", "properties": {"text": "CAPTCHA placeholder"} }
      ]
    },
    {
      "type": "button",
      "componentNodeId": "${n}",
      "properties": { "text": "Submit", "horizontalSizing": "FILL" }
    }
  ]
}
\`\`\`
*UX decision: Each major section (file upload, captcha, submit button) is a separate item in the main "items" array. The submit button is NOT nested inside any other container.*

### Settings Screen with Smart Variants:
\`\`\`json
{
  "layoutContainer": {
    "name": "Settings Screen",
    "layoutMode": "VERTICAL",
    "width": 360,
    "itemSpacing": 8
  },
  "items": [
    {
      "type": "list-item",
      "componentNodeId": "${a}",
      "properties": {
        "text": "Personal details",
        "horizontalSizing": "FILL",
        "variants": {
          "Condition": "1-line"
        }
      }
    },
    {
      "type": "list-item",
      "componentNodeId": "${a}",
      "properties": {
        "text": "Change language",
        "trailing-text": "English",
        "horizontalSizing": "FILL",
        "variants": {
          "Condition": "2-line",
          "Trailing": "Icon"
        }
      }
    }
  ]
}
\`\`\`
*UX Note: You only need to specify variants you want to change. The plugin automatically fills in defaults for other variant properties.*

**IMPORTANT**: Notice how we use the actual componentNodeId values from your design system, NOT placeholder IDs.`}getExampleId(e,t){if(!e||!e.byType||e.isEmpty)return`${t}_actual_id`;const s=e.byType[t];return s&&Array.isArray(s)&&s.length>0?s[0].id:`${t}_actual_id`}containsKeywords(e,t){return t.some(t=>e.includes(t))}}
"undefined"!=typeof window&&(window.AIDesignerPromptGenerator=AIDesignerPromptGenerator);
    </script>
    
    <!-- MAIN UI SCRIPT WITH SESSION MANAGEMENT -->
    <script>
        // Platform toggle functionality


        // Global Variables and Core Functions
        const componentTypes = {
            'Navigation': ['appbar', 'navbar', 'tab', 'tabs', 'breadcrumb', 'pagination', 'navigation', 'sidebar', 'bottom-navigation', 'menu'],
            'Input': ['button', 'input', 'textarea', 'select', 'checkbox', 'radio', 'switch', 'slider', 'searchbar', 'chip'],
            'Display': ['card', 'list', 'list-item', 'avatar', 'image', 'icon', 'text', 'header', 'badge', 'tooltip'],
            'Feedback': ['snackbar', 'alert', 'dialog', 'modal', 'progress', 'skeleton', 'loading', 'toast'],
            'Layout': ['container', 'frame', 'grid', 'divider', 'spacer'],
            'Specialized': ['fab', 'actionsheet', 'bottomsheet', 'chart', 'table', 'calendar', 'timeline', 'upload', 'gallery', 'map', 'rating', 'cart', 'price']
        };
        
        let currentTab = 'design-system';
        let scanResults = [];
        let colorStyles = null; // Store color styles from scan
        let textStyles = null; // Store text styles from scan
        let currentFilter = 'all';
        let searchQuery = '';
        let lastGeneratedJSON = null;
        let promptGenerator = null;
        let selectedImage = null; // Explicitly initialize as null

        // NEW: Enhanced state management for sessions
        let designState = {
            scanData: null
        };

        // NEW: Session management variables
        let currentSessionData = null;
        let pendingSessionRestore = null;

        // Validation and helper functions
        // Debug function to check image state (call this in console if needed)
function debugImageState() {
    console.log('üîç DEBUG IMAGE STATE:');
    console.log('  - selectedImage:', selectedImage);
    console.log('  - !!selectedImage:', !!selectedImage);
    console.log('  - typeof selectedImage:', typeof selectedImage);
    console.log('  - isValidImageSelected():', isValidImageSelected());
    
    const input = document.getElementById('imageInput');
    console.log('  - input.files.length:', input ? input.files.length : 'no input');
    console.log('  - input.value:', input ? input.value : 'no input');
}

// More robust validation in prompt generation
function isValidImageSelected() {
    return selectedImage && 
           selectedImage.base64 && 
           selectedImage.type && 
           selectedImage.base64.length > 0;
}
        function validateAndFixJSONEnhanced(jsonString) {
            try {
                const parsed = JSON.parse(jsonString);
                return { isValid: true, data: parsed, errors: [] };
            } catch (e) {
                console.log("üîß JSON parsing failed, attempting fixes...");
                
                let fixed = jsonString.trim();
                fixed = fixed.replace(/,(\s*[}\]])/g, '$1');
                fixed = fixed.replace(/}(\s*){/g, '},\n$1{');
                
                if (fixed.includes('[') && !fixed.includes(']')) {
                    fixed = fixed + ']';
                }
                
                const openBraces = (fixed.match(/{/g) || []).length;
                const closeBraces = (fixed.match(/}/g) || []).length;
                if (openBraces > closeBraces) {
                    fixed = fixed + '}';
                }
                
                fixed = fixed.replace(/"variants":\s*{[^}]*$/, '"variants": {}');
                
                try {
                    const parsed = JSON.parse(fixed);
                    console.log("‚úÖ JSON fixed successfully!");
                    return { isValid: true, data: parsed, errors: [] };
                } catch (e2) {
                    console.error("‚ùå Could not fix JSON:", e2.message);
                    return { 
                        isValid: false, 
                        data: null, 
                        errors: [e.message, "Auto-fix failed: " + e2.message] 
                    };
                }
            }
        }
// NEW: AI Self-Check & Retry System - Phase 1: Validation Layer
        function validateAIResponse(jsonData, scanResults) {
            const validationResult = {
                isValid: true,
                errors: [],
                warnings: [],
                severity: 'none' // 'low', 'medium', 'high', 'critical'
            };
            
            console.log('üîç Starting AI response validation...');
            
            // Step 1: Basic Structure Validation
            if (!jsonData.layoutContainer && !jsonData.items) {
                validationResult.isValid = false;
                validationResult.errors.push('Missing required layoutContainer or items');
                validationResult.severity = 'critical';
                return validationResult;
            }
            
            if (!jsonData.items || !Array.isArray(jsonData.items)) {
                validationResult.isValid = false;
                validationResult.errors.push('Missing or invalid items array');
                validationResult.severity = 'critical';
                return validationResult;
            }
            
            // Step 2: Component ID Validation
            const availableComponents = new Set();
            if (scanResults && Array.isArray(scanResults)) {
                scanResults.forEach(comp => availableComponents.add(comp.id));
            }
            
            let invalidComponentCount = 0;
            jsonData.items.forEach((item, index) => {
                if (item.type && !item.type.startsWith('native-') && !item.type.startsWith('layoutContainer')) {
                    if (!item.componentNodeId) {
                        validationResult.errors.push(`Item ${index}: Missing componentNodeId for type "${item.type}"`);
                        invalidComponentCount++;
                    } else if (!availableComponents.has(item.componentNodeId)) {
                        validationResult.errors.push(`Item ${index}: Component ID "${item.componentNodeId}" not found in design system`);
                        invalidComponentCount++;
                    }
                }
            });
            
            // Set severity based on component issues
            if (invalidComponentCount > 0) {
                validationResult.isValid = false;
                if (invalidComponentCount >= jsonData.items.length * 0.5) {
                    validationResult.severity = 'critical';
                } else if (invalidComponentCount >= jsonData.items.length * 0.3) {
                    validationResult.severity = 'high';
                } else {
                    validationResult.severity = 'medium';
                }
            }
            
            console.log(`‚úÖ Validation complete. Valid: ${validationResult.isValid}, Severity: ${validationResult.severity}`);
            return validationResult;
        }
        // NEW: AI Self-Check & Retry System - Phase 2: Retry Engine
        function createRetryPrompt(originalPrompt, validationResult, scanResults, attemptNumber) {
            console.log(`üîÑ Creating retry prompt (attempt ${attemptNumber})`);
            
            let retryStrategy = '';
            let enhancedPrompt = originalPrompt;
            
            // Determine retry strategy based on error severity and attempt number
            if (attemptNumber === 1) {
                // First retry: Specific error fixes
                if (validationResult.errors.some(err => err.includes('Component ID') || err.includes('not found'))) {
                    retryStrategy = 'COMPONENT_ID_FIX';
                    enhancedPrompt += '\n\n// üîß COMPONENT ID CORRECTION NEEDED:\n';
                    enhancedPrompt += '// The previous response used invalid component IDs.\n';
                    enhancedPrompt += '// You MUST use ONLY the exact componentNodeId values from the design system list above.\n';
                    enhancedPrompt += '// NEVER use placeholder IDs like "button_id" or "input_id".\n';
                    
                    // Add available component IDs as reminder
                    if (scanResults && scanResults.length > 0) {
                        enhancedPrompt += '// Available component IDs:\n';
                        scanResults.slice(0, 5).forEach(comp => {
                            enhancedPrompt += `// - ${comp.suggestedType}: "${comp.id}"\n`;
                        });
                    }
                }
                
                if (validationResult.errors.some(err => err.includes('Missing') && err.includes('layoutContainer'))) {
                    retryStrategy = 'STRUCTURE_FIX';
                    enhancedPrompt += '\n\n// üîß STRUCTURE CORRECTION NEEDED:\n';
                    enhancedPrompt += '// Your response must have BOTH "layoutContainer" and "items" at the top level.\n';
                    enhancedPrompt += '// Follow this exact structure:\n';
                    enhancedPrompt += '// {"layoutContainer": {...}, "items": [...]}\n';
                }
                
            } else if (attemptNumber === 2) {
                // Second retry: Simplified approach
                retryStrategy = 'SIMPLIFIED';
                enhancedPrompt = `Create a SIMPLIFIED version of: ${originalPrompt}
                
// üéØ SIMPLIFIED GENERATION RULES:
// - Use ONLY basic components (button, input, text)
// - NO variants or complex properties
// - Keep layout simple with VERTICAL layoutMode
// - Maximum 3-4 items total
// - Use exact componentNodeId values from design system`;
                
            } else {
                // Third+ retry: Basic fallback
                retryStrategy = 'BASIC_FALLBACK';
                enhancedPrompt = `Create a basic UI layout with:
- 1 text element for title
- 1-2 input elements  
- 1 button element
- Simple vertical layout
- Use ONLY exact componentNodeId values from the available design system components`;
            }
            
            console.log(`üìù Retry strategy: ${retryStrategy}`);
            return {
                prompt: enhancedPrompt,
                strategy: retryStrategy,
                attemptNumber: attemptNumber
            };
        }
        
        // Retry execution function
        async function executeRetry(originalPrompt, validationResult, scanResults, attemptNumber, maxRetries = 3) {
            if (attemptNumber > maxRetries) {
                throw new Error(`Failed after ${maxRetries} attempts. Last errors: ${validationResult.errors.join(', ')}`);
            }
            
            showStatus('generationStatus', `üîÑ Improving result (attempt ${attemptNumber}/${maxRetries})...`, 'info');
            
            const retryData = createRetryPrompt(originalPrompt, validationResult, scanResults, attemptNumber);
            
            try {
                const apiKey = await getApiKeyFromBackend();
                const response = await callGeminiAPI(apiKey, retryData.prompt, selectedImage);
                
                const validation = validateAndFixJSONEnhanced(response);
                if (!validation.isValid) {
                    throw new Error(`JSON parsing failed on retry ${attemptNumber}`);
                }
                
                const aiValidation = validateAIResponse(validation.data, scanResults);
                if (aiValidation.isValid) {
                    console.log(`‚úÖ Retry ${attemptNumber} successful!`);
                    return validation.data;
                } else {
                    console.log(`‚ùå Retry ${attemptNumber} failed validation, trying again...`);
                    return await executeRetry(originalPrompt, aiValidation, scanResults, attemptNumber + 1, maxRetries);
                }
                
            } catch (error) {
                console.log(`‚ùå Retry ${attemptNumber} failed:`, error.message);
                return await executeRetry(originalPrompt, validationResult, scanResults, attemptNumber + 1, maxRetries);
            }
        }
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            currentTab = tabId;
        }

        function showStatus(containerId, message, type) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function clearStatus(containerId) {
            const container = document.getElementById(containerId);
            if(container) container.innerHTML = '';
        }

        async function copyToClipboard(text) {
            try {
                // Try modern clipboard API first
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return;
                }
                
                // Fallback method for environments where clipboard API is unavailable
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    console.log('‚úÖ Text copied using fallback method');
                } catch (fallbackErr) {
                    console.error('‚ùå Fallback copy failed:', fallbackErr);
                    throw new Error('Copy failed - please manually copy the text');
                } finally {
                    document.body.removeChild(textArea);
                }
            } catch (err) {
                console.error('Failed to copy:', err);
                // As a last resort, log the text so user can manually copy
                console.log('üìã Copy failed - here is the text to copy manually:');
                console.log(text);
                throw err;
            }
        }
        
        // NEW: Session Management Functions
        function showSessionModal(sessionData) {
            currentSessionData = sessionData;
            
            // Populate modal with session data
            document.getElementById('sessionFrameName').textContent = sessionData.designState.frameName || 'Unknown Frame';
            document.getElementById('sessionLastModified').textContent = formatTime(sessionData.lastModified);
            
            const historyList = document.getElementById('sessionHistoryList');
            historyList.innerHTML = '<li>Session data available</li>';
            
            document.getElementById('sessionModal').style.display = 'flex';
        }

        function closeSessionModal() {
            document.getElementById('sessionModal').style.display = 'none';
            currentSessionData = null;
        }

        function restoreSession() {
            if (!currentSessionData) return;
            
            // Send restore request to backend
            parent.postMessage({
                pluginMessage: {
                    type: 'restore-session',
                    payload: currentSessionData
                }
            }, '*');
            
            closeSessionModal();
        }

        function startNewSession() {
            // Clear session and start fresh
            parent.postMessage({
                pluginMessage: {
                    type: 'clear-current-session'
                }
            }, '*');
            
            startFresh();
            closeSessionModal();
        }

        function showAllSessions() {
            parent.postMessage({
                pluginMessage: {
                    type: 'get-all-sessions'
                }
            }, '*');
        }

        function closeAllSessionsModal() {
            document.getElementById('allSessionsModal').style.display = 'none';
        }

        function renderAllSessions(sessions, currentFileId) {
            const container = document.getElementById('allSessionsList');
            container.innerHTML = '';
            
            if (sessions.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #586069; padding: 20px;">No active sessions found</p>';
                return;
            }
            
            sessions.forEach(session => {
                const isCurrentFile = session.fileId === currentFileId;
                
                const sessionElement = document.createElement('div');
                sessionElement.className = `session-item ${isCurrentFile ? 'current-file' : ''}`;
                
                sessionElement.innerHTML = `
                    <div class="session-item-header">
                        <div class="session-file-name">
                            ${session.fileName}
                            ${isCurrentFile ? '<span class="current-file-badge">Current File</span>' : ''}
                        </div>
                        <div class="session-time">${formatTime(session.lastModified)}</div>
                    </div>
                    <div class="session-item-details">
                        Frame: ${session.designState.frameName || 'Unknown'} ‚Ä¢ 
                        Scan data available
                    </div>
                    <div class="session-item-actions">
                        ${isCurrentFile ? 
                            `<button class="btn btn-secondary" onclick="restoreSpecificSession('${session.fileId}')">üìÇ Restore</button>` :
                            `<button class="btn btn-secondary" onclick="showSessionDetails('${session.fileId}')">üëÅÔ∏è View</button>`
                        }
                        <button class="btn btn-secondary" onclick="deleteSession('${session.fileId}')">üóëÔ∏è Delete</button>
                    </div>
                `;
                
                container.appendChild(sessionElement);
            });
            
            document.getElementById('allSessionsModal').style.display = 'flex';
        }

        function restoreSpecificSession(fileId) {
            // This will be called for current file sessions
            if (currentSessionData && currentSessionData.fileId === fileId) {
                restoreSession();
            }
            closeAllSessionsModal();
        }

        function showSessionDetails(fileId) {
            // For sessions from other files, just show info
            showStatus('generationStatus', 'This session is from a different file. Switch to that file to restore it.', 'info');
            closeAllSessionsModal();
        }

        function deleteSession(fileId) {
            if (confirm('Delete this session permanently?')) {
                parent.postMessage({
                    pluginMessage: {
                        type: 'delete-session',
                        payload: fileId
                    }
                }, '*');
            }
        }


        function formatTime(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / (1000 * 60));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }

        // Design System Functions
        function scanDesignSystem() {
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('scanBtn').textContent = 'üîç Scanning...';
            parent.postMessage({ pluginMessage: { type: 'scan-design-system' } }, '*');
        }

        function rescanDesignSystem() {
            scanDesignSystem();
        }


        function createExportButton() {
            // Export button now exists in HTML, just ensure it's properly configured
            const exportBtn = document.getElementById('exportRawBtn');
            if (exportBtn) {
                exportBtn.title = 'Export raw scan results as JSON';
            }
        }


        // Status display function
        function showScanStatus(message, type) {
            console.log(`üìã Status [${type}]: ${message}`);
            // Try to find status element, fallback to console
            const statusElement = document.getElementById('scan-status') || document.querySelector('.scan-status');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `scan-status ${type}`;
            }
        }

        // Simple export function that includes text styles
        function exportRawScanData() {
            console.log('üîç Export called - checking data availability...');
            
            // Get scan data from multiple possible sources
            let components = scanResults || [];
            let colorStylesData = colorStyles || null;
            let textStylesData = textStyles || null;  // ‚úÖ Use global textStyles
            
            // Try to get full scan session data if available
            if (window.designSystemUI && window.designSystemUI.fullScanSession) {
                const session = window.designSystemUI.fullScanSession;
                components = session.components || components;
                colorStylesData = session.colorStyles || colorStylesData;
                textStylesData = session.textStyles || null;
                console.log('üìã Using data from DesignSystemUI session');
                console.log('üìù DesignSystemUI session debug:', {
                    hasSession: !!session,
                    hasTextStyles: !!session.textStyles,
                    textStylesLength: session.textStyles ? session.textStyles.length : 0,
                    textStylesContent: session.textStyles ? session.textStyles.slice(0, 3) : null
                });
            }
            
            console.log('üìä Export data check:', {
                components: components.length,
                hasColorStyles: !!colorStylesData,
                hasTextStyles: !!textStylesData,
                textStylesCount: textStylesData ? textStylesData.length : 0
            });
            
            if (!components || components.length === 0) {
                showScanStatus('‚ùå No scan data available to export', 'error');
                return;
            }

            try {
                // Calculate style counts
                const colorStylesCount = colorStylesData ? 
                    Object.values(colorStylesData).reduce((sum, styles) => sum + styles.length, 0) : 0;
                const textStylesCount = textStylesData ? textStylesData.length : 0;
                
                // Prepare comprehensive export data
                const exportData = {
                    metadata: {
                        exportedAt: new Date().toISOString(),
                        componentCount: components.length,
                        colorStylesCount: colorStylesCount,
                        textStylesCount: textStylesCount,
                        exportVersion: '2.0',
                        source: 'Figma Design System Scanner'
                    },
                    components: components,
                    colorStyles: colorStylesData,
                    textStyles: textStylesData
                };

                // Generate filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `design-system-raw-data-${timestamp}.json`;

                // Download the JSON file
                downloadJsonFile(exportData, filename);

                const message = `‚úÖ Exported ${components.length} components, ${colorStylesCount} color styles, ${textStylesCount} text styles`;
                showScanStatus(message, 'success');
                console.log(`üì• ${message} to ${filename}`);
            } catch (error) {
                console.error('Export failed:', error);
                showScanStatus('‚ùå Export failed. Please try again.', 'error');
            }
        }

        function downloadJsonFile(data, filename) {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up the URL object
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        function displaySavedScan(components, scanTime) {
            scanResults = components || [];
            const statusContainer = document.getElementById('scanStatusContainer');
            const statusText = document.getElementById('scanStatusText');
            const rescanBtn = document.getElementById('rescanBtn');
            
            if (scanResults.length > 0) {
                if (statusContainer) statusContainer.classList.add('loaded');
                if (statusText) {
                    const timeAgo = scanTime ? getTimeAgo(scanTime) : 'recently';
                    statusText.textContent = `‚úÖ ${scanResults.length} components loaded (scanned ${timeAgo})`;
                }
                if (rescanBtn) rescanBtn.style.display = 'inline-block';
                
                // Show export button when results are available
                createExportButton();
                const exportBtn = document.getElementById('exportRawBtn');
                if (exportBtn) exportBtn.style.display = 'inline-block';
                
                displayComponents();
                enableGeneratorTab();
            } else {
                if (statusText) statusText.textContent = 'No design system scanned yet';
                if (rescanBtn) rescanBtn.style.display = 'none';
                const exportBtn = document.getElementById('exportRawBtn');
                if (exportBtn) exportBtn.style.display = 'none';
            }
        }

        function enableGeneratorTab() {
            const generatorTab = document.getElementById('generatorTab');
            if (generatorTab) generatorTab.disabled = false;
        }

        function getTimeAgo(timestamp) {
            if (!timestamp) return 'some time ago';
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / (1000 * 60));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes} minutes ago`;
            if (hours < 24) return `${hours} hours ago`;
            return `${days} days ago`;
        }

        function displayComponents() {
            const section = document.getElementById('componentsSection');
            const promptSection = document.getElementById('promptSection');
            
            if (scanResults.length === 0) {
                if (section) section.style.display = 'none';
                if (promptSection) promptSection.style.display = 'none';
                return;
            }
            
            scanResults.forEach(comp => {
                if (comp.isVerified === undefined) {
                    comp.isVerified = false;
                }
            });
            
            renderComponentList();
            updateComponentStats();
            
            if (section) section.style.display = 'block';
            if (promptSection) promptSection.style.display = 'block';
        }

        function renderComponentList() {
            const container = document.getElementById('componentsList');
            if (!container) return;
            
            const filteredComponents = getFilteredComponents();
            container.innerHTML = '';
            
            filteredComponents.forEach(comp => {
                const item = createComponentItem(comp);
                container.appendChild(item);
            });
            
            container.querySelectorAll('.type-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const componentId = e.target.getAttribute('data-component-id');
                    const newType = e.target.value;
                    handleTypeChange(componentId, newType);
                });
            });
            
            container.querySelectorAll('.navigate-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const componentId = e.target.getAttribute('data-component-id');
                    const pageName = e.target.getAttribute('data-page-name');
                    handleNavigation(componentId, pageName);
                });
            });
        }

        function handleTypeChange(componentId, newType) {
            const component = scanResults.find(comp => comp.id === componentId);
            if (component) {
                component.suggestedType = newType;
                component.confidence = 1.0;
                component.isVerified = true;
                renderComponentList();
                updateComponentStats();
                parent.postMessage({
                    pluginMessage: {
                        type: 'update-component-type',
                        payload: { componentId, newType }
                    }
                }, '*');
            }
        }

        function handleNavigation(componentId, pageName) {
            parent.postMessage({
                pluginMessage: {
                    type: 'navigate-to-component',
                    componentId,
                    pageName
                }
            }, '*');
        }

        function createComponentItem(comp) {
            const item = document.createElement('div');
            item.className = 'component-item';
            item.dataset.componentId = comp.id;
            
            const confidence = Math.round(comp.confidence * 100);
            let confidenceClass = 'confidence-low';
            if (comp.isVerified) confidenceClass = 'confidence-verified';
            else if (confidence >= 80) confidenceClass = 'confidence-high';
            else if (confidence >= 60) confidenceClass = 'confidence-medium';
            
            const statusIcon = comp.isVerified ? '‚úì' : (comp.suggestedType === 'unknown' ? '‚ùì' : 'ü§ñ');
            const statusClass = comp.isVerified ? 'icon-verified' : (comp.suggestedType === 'unknown' ? 'icon-unknown' : 'icon-auto');
            const selectOptions = createSelectOptions(comp.suggestedType);
            
            item.innerHTML = `
                <div class="component-info">
                    <div class="component-name">${comp.name}</div>
                    <div class="component-meta">
                        <div class="type-selector">
                            <span class="status-icon ${statusClass}">${statusIcon}</span>
                            <select class="type-select" data-component-id="${comp.id}">${selectOptions}</select>
                        </div>
                        <span class="confidence-badge ${confidenceClass}">${comp.isVerified ? 'Manual' : confidence + '%'}</span>
                        <span class="page-info">üìÑ ${comp.pageInfo?.pageName || 'Unknown'}</span>
                    </div>
                </div>
                <div class="component-actions">
                    <button class="btn-action navigate-btn" data-component-id="${comp.id}" data-page-name="${comp.pageInfo?.pageName || ''}" title="View in Figma">üëÅÔ∏è</button>
                </div>
            `;
            
            return item;
        }

        function createSelectOptions(selectedType) {
            let options = '';
            Object.keys(componentTypes).forEach(category => {
                options += `<optgroup label="${category}">`;
                componentTypes[category].forEach(type => {
                    const isSelected = type === selectedType ? 'selected' : '';
                    options += `<option value="${type}" ${isSelected}>${type}</option>`;
                });
                options += '</optgroup>';
            });
            
            const unknownSelected = selectedType === 'unknown' ? 'selected' : '';
            options += `<optgroup label="Other"><option value="unknown" ${unknownSelected}>unknown</option></optgroup>`;
            
            return options;
        }

        function getFilteredComponents() {
            let filtered = scanResults;
            
            if (searchQuery) {
                filtered = filtered.filter(comp => 
                    comp.name.toLowerCase().includes(searchQuery.toLowerCase()) || 
                    comp.suggestedType.toLowerCase().includes(searchQuery.toLowerCase())
                );
            }
            
            switch (currentFilter) {
                case 'unknown':
                    return filtered.filter(comp => comp.suggestedType === 'unknown');
                case 'low':
                    return filtered.filter(comp => comp.confidence < 0.6 && !comp.isVerified);
                case 'verified':
                    return filtered.filter(comp => comp.isVerified);
                default:
                    return filtered;
            }
        }

        function updateComponentStats() {
            const total = scanResults.length;
            const highConf = scanResults.filter(comp => comp.confidence >= 0.8 && !comp.isVerified).length;
            const lowConf = scanResults.filter(comp => (comp.confidence < 0.6 || comp.suggestedType === 'unknown') && !comp.isVerified).length;
            const verified = scanResults.filter(comp => comp.isVerified).length;
            
            document.getElementById('totalCount').textContent = total;
            document.getElementById('highConfCount').textContent = highConf;
            document.getElementById('lowConfCount').textContent = lowConf;
            document.getElementById('verifiedCount').textContent = verified;
        }

        function setupComponentListeners() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    searchQuery = e.target.value;
                    renderComponentList();
                });
            }
            
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilter = e.target.dataset.filter;
                    renderComponentList();
                });
            });
        }


        // API Functions
        function setupApiKeyHandling() {
            const apiKeyInput = document.getElementById('apiKey');
            if (apiKeyInput) {
                apiKeyInput.addEventListener('focus', function() {
                    if (this.getAttribute('data-has-key') === 'true') {
                        this.value = '';
                        this.setAttribute('data-has-key', 'false');
                    }
                });
                
                apiKeyInput.addEventListener('input', function() {
                    if (this.value.length > 0) {
                        this.setAttribute('data-has-key', 'false');
                    }
                });
            }
        }

        function saveApiKey() {
            const apiKeyInput = document.getElementById('apiKey');
            const saveBtn = document.getElementById('saveBtn');
            if (!apiKeyInput || !saveBtn) return;
            
            const apiKey = apiKeyInput.value.trim();
            
            if (apiKeyInput.getAttribute('data-has-key') === 'true' && apiKey.includes('‚óè')) {
                showStatus('connectionStatus', '‚ÑπÔ∏è API key already saved', 'info');
                return;
            }
            
            if (!apiKey) {
                showStatus('connectionStatus', '‚ùå Please enter an API key', 'error');
                return;
            }
            
            saveBtn.disabled = true;
            saveBtn.textContent = 'üíæ Saving...';
            parent.postMessage({
                pluginMessage: {
                    type: 'save-api-key',
                    payload: apiKey
                }
            }, '*');
        }

        // Updated: Use backend for connection testing
        async function testGeminiConnection() {
            const testBtn = document.getElementById('testBtn');
            if (!testBtn) return;
            
            testBtn.disabled = true;
            testBtn.textContent = 'üîå Testing...';
            showStatus('connectionStatus', 'üîÑ Testing connection via backend...', 'info');
            
            try {
                // Send test request to backend
                parent.postMessage({
                    pluginMessage: {
                        type: 'test-gemini-connection'
                    }
                }, '*');
                
                // Response will be handled by message handler
                
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                showStatus('connectionStatus', `‚ùå Error: ${errorMessage}`, 'error');
                testBtn.disabled = false;
                testBtn.textContent = 'üîå Test Connection';
            }
        }

        // Image Functions
        function validateImageFile(file) {
            const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
            const maxSize = 4 * 1024 * 1024;
            
            if (!validTypes.includes(file.type)) {
                showStatus('generationStatus', `‚ùå Invalid file type. Please use JPG, PNG, WEBP, or GIF.`, 'error');
                return false;
            }
            
            if (file.size > maxSize) {
                showStatus('generationStatus', `‚ùå File is too large. Maximum size is 4MB.`, 'error');
                return false;
            }
            
            return true;
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function handleImageSelection(file) {
            if (!validateImageFile(file)) {
                return;
            }
            
            try {
                const base64 = await fileToBase64(file);
                selectedImage = {
                    base64: base64,
                    type: file.type,
                    name: file.name
                };
                
                document.getElementById('previewImg').src = `data:${file.type};base64,${base64}`;
                document.getElementById('imagePreview').style.display = 'flex';
                document.getElementById('uploadPrompt').style.display = 'none';
                document.getElementById('imageUploadArea').classList.add('has-image');
                
                showStatus('generationStatus', `‚úÖ Image "${file.name}" loaded successfully.`, 'success');
            } catch (error) {
                console.error('Error processing image:', error);
                showStatus('generationStatus', '‚ùå Could not process the image file.', 'error');
            }
        }


        // AI Generator & Iteration Functions
        function startFresh() {
    // Reset state object
    designState = {
        scanData: null
    };

    // üîß ENSURE CLEAN IMAGE STATE: Force clear selectedImage
    selectedImage = null;
    // Clear color styles data
    colorStyles = null;
    console.log('üîÑ startFresh called, selectedImage reset to:', selectedImage);

    // Update UI elements
    // (Most UI elements removed in cleanup)

    clearStatus('generationStatus');
}

        
        


        
        


        async function getApiKeyFromBackend() {
            showStatus('generationStatus', 'üîÑ Getting API key...', 'info');
            
            const apiKey = await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    window.removeEventListener('message', handler);
                    reject(new Error('Timeout getting API key.'));
                }, 3000);
                
                const handler = (event) => {
                    const msg = event.data.pluginMessage;
                    if (msg && (msg.type === 'api-key-found' || msg.type === 'api-key-not-found')) {
                        clearTimeout(timeout);
                        window.removeEventListener('message', handler);
                        resolve(msg.payload || null);
                    }
                };
                
                window.addEventListener('message', handler);
                parent.postMessage({ pluginMessage: { type: 'get-api-key' } }, '*');
            });
            
            if (!apiKey) throw new Error('API key not found. Please save it in settings.');
            return apiKey;
        }

        // Updated: Use backend for Gemini API calls
        async function callGeminiAPI(apiKey, fullPrompt, image) {
            showStatus('generationStatus', 'ü§ñ Calling Gemini API via backend...', 'info');
            
            return new Promise((resolve, reject) => {
                // Store the resolve/reject functions to be called by message handler
                window.pendingGeminiRequest = { resolve, reject };
                
                // Send request to backend
                parent.postMessage({
                    pluginMessage: {
                        type: 'generate-with-gemini',
                        payload: {
                            prompt: fullPrompt,
                            image: image,
                            scanResults: scanResults,
                            platform: currentPlatform
                        }
                    }
                }, '*');
            });
        }

        function copyGeneratedJSON() {
            if (lastGeneratedJSON) {
                copyToClipboard(JSON.stringify(lastGeneratedJSON, null, 2))
                    .then(() => showStatus('generationStatus', 'üìã JSON copied to clipboard!', 'success'));
            }
        }



        async function renderFromJSON() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            const jsonRenderBtn = document.getElementById('jsonRenderBtn');
            const forceRender = document.getElementById('force-render')?.checked || false;
            
            if (!jsonInput) {
                showStatus('generationStatus', '‚ùå Please paste JSON from 3-stage pipeline.', 'error');
                return;
            }
            
            jsonRenderBtn.disabled = true;
            jsonRenderBtn.textContent = 'üîÑ Rendering...';
            showStatus('generationStatus', 'üé® Rendering JSON from 3-stage pipeline...', 'info');
            
            // Hide validation feedback
            document.getElementById('validation-feedback').style.display = 'none';
            
            try {
                // Clean JSON (remove markdown if present)
                let cleanJson = jsonInput.replace(/^```json\n/, '').replace(/\n```$/, '').trim();
                
                // Try to parse JSON
                const parsedJSON = JSON.parse(cleanJson);
                
                // Send to backend for rendering
                parent.postMessage({
                    pluginMessage: {
                        type: 'render-json-direct',
                        payload: {
                            json: parsedJSON,
                            source: '3-stage-pipeline',
                            forceRender: forceRender
                        }
                    }
                }, '*');
                
            } catch (error) {
                console.error('‚ùå JSON parse error:', error);
                showStatus('generationStatus', `‚ùå Invalid JSON: ${error.message}`, 'error');
                
                jsonRenderBtn.disabled = false;
                jsonRenderBtn.textContent = 'üé® Render JSON';
            }
        }



        function toggleJSONView() {
            const jsonOutput = document.getElementById('jsonOutput');
            if (jsonOutput) {
                jsonOutput.style.display = jsonOutput.style.display === 'none' ? 'block' : 'none';
            }
        }


        // Session state saving
        function saveCurrentSession() {
            // Save scan data only
            parent.postMessage({
                pluginMessage: {
                    type: 'save-current-session',
                    payload: {
                        scanData: scanResults
                    }
                }
            }, '*');
        }

        // Message Handler and Initialization
        window.onmessage = (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;

            console.log("üì® Message from plugin:", msg.type);
            
            // DEBUG: Log scan-results message content
            if (msg.type === 'scan-results') {
                console.log('üìù scan-results message content:', {
                    hasComponents: !!msg.components,
                    componentCount: msg.components ? msg.components.length : 0,
                    hasColorStyles: !!msg.colorStyles,
                    hasTextStyles: !!msg.textStyles,
                    textStylesCount: msg.textStylesCount || 0,
                    textStylesArray: msg.textStyles ? msg.textStyles.length : 0,
                    textStylesPreview: msg.textStyles ? msg.textStyles.slice(0, 3).map(s => s.name) : null
                });
            }

            switch (msg.type) {
                // API and session handlers
                case 'api-key-loaded':
                    console.log('‚úÖ API key loaded from storage');
                    const apiKeyInput = document.getElementById('apiKey');
                    if (apiKeyInput) {
                        apiKeyInput.value = '‚óè'.repeat(40);
                        apiKeyInput.setAttribute('data-has-key', 'true');
                    }
                    enableGeneratorTab();
                    showStatus('connectionStatus', '‚úÖ API key loaded from previous session', 'success');
                    break;

                case 'api-key-saved':
                    const apikeySavedSaveBtn = document.getElementById('saveBtn');
                    if (apikeySavedSaveBtn) {
                        apikeySavedSaveBtn.disabled = false;
                        apikeySavedSaveBtn.textContent = 'üíæ Save API Key';
                    }
                    showStatus('connectionStatus', '‚úÖ API key saved successfully!', 'success');
                    const keyInput = document.getElementById('apiKey');
                    if (keyInput) {
                        keyInput.value = '‚óè'.repeat(40);
                        keyInput.setAttribute('data-has-key', 'true');
                    }
                    enableGeneratorTab();
                    break;

                // Design system handlers
                case 'scan-progress':
                    // Handle scan progress updates
                    const progress = msg.progress;
                    const progressPercent = Math.round((progress.current / progress.total) * 100);
                    
                    const scanBtn = document.getElementById('scanBtn');
                    if (scanBtn) {
                        scanBtn.disabled = true;
                        scanBtn.textContent = `‚è≥ ${progressPercent}% - ${progress.status}`;
                    }
                    
                    // Update scan status display directly (don't use showStatus to preserve DOM structure)
                    const scanStatusElement = document.getElementById('scanStatusText');
                    if (scanStatusElement) {
                        scanStatusElement.textContent = `üîÑ ${progress.status} (${progressPercent}%)`;
                        scanStatusElement.className = 'scan-status-text info';
                    }
                    break;

                case 'scan-results':
                    const completedScanBtn = document.getElementById('scanBtn');
                    if (completedScanBtn) {
                        completedScanBtn.disabled = false;
                        completedScanBtn.textContent = 'üîç Scan Design System';
                    }
                    
                    // Store components, colorStyles, AND textStyles
                    colorStyles = msg.colorStyles || null;
                    textStyles = msg.textStyles || null;  // ‚úÖ FIX: Store text styles!
                    
                    // Debug logging
                    console.log('üé® Received colorStyles:', colorStyles);
                    console.log('üìù Received textStyles:', textStyles);
                    if (colorStyles) {
                        const count = Object.values(colorStyles).reduce((sum, styles) => sum + styles.length, 0);
                        console.log(`üé® Total color styles: ${count}`);
                    }
                    if (textStyles) {
                        console.log(`üìù Total text styles: ${textStyles.length}`);
                        console.log('üìù Text style names:', textStyles.map(s => s.name));
                    }
                    
                    // Let displaySavedScan handle the final status update
                    displaySavedScan(msg.components, Date.now());
                    break;

                case 'scan-error':
                    const errorScanBtn = document.getElementById('scanBtn');
                    if (errorScanBtn) {
                        errorScanBtn.disabled = false;
                        errorScanBtn.textContent = 'üîç Scan Design System';
                    }
                    
                    const scanErrorElement = document.getElementById('scanStatusText');
                    if (scanErrorElement) {
                        showStatus(scanErrorElement.parentElement.id, `‚ùå Scan failed: ${msg.error}`, 'error');
                    }
                    break;

                case 'saved-scan-loaded':
                    console.log('‚úÖ Design system loaded from storage');
                    // Store colorStyles if available in saved data
                    colorStyles = msg.colorStyles || null;
                    displaySavedScan(msg.components, msg.scanTime);
                    break;

                case 'llm-prompt-generated':
                    copyToClipboard(msg.prompt);
                    const scanStatusText = document.getElementById('scanStatusText');
                    if(scanStatusText) {
                        showStatus(scanStatusText.parentElement.id, 'üìã Prompt copied to clipboard!', 'success');
                    }
                    break;

                // UI generation handlers
                case 'ui-generated-success':
                    clearStatus('generationStatus');
                    document.getElementById('userPrompt').value = '';
                    break;
                
                case 'ui-modified-success':
                    clearStatus('generationStatus');
                    showStatus('generationStatus', '‚úÖ UI updated successfully!', 'success');
                    break;
                
                case 'ui-generation-error':
                    showStatus('generationStatus', `‚ùå Generation error: ${msg.error}`, 'error');
                    break;

                // Pipeline handlers
                case 'pipeline-success':
                    clearStatus('generationStatus');
                    
                    // Show success with detailed stats
                    const stats = msg.result.pipelineStats;
                    const message = `‚úÖ Pipeline completed! ${stats.totalStagesWithAI}/${stats.stageAIUsage ? Object.keys(stats.stageAIUsage).length : 5} stages used AI`;
                    showStatus('generationStatus', message, 'success');
                    
                    // UI was generated successfully
                    
                    document.getElementById('userPrompt').value = '';
                    break;

                case 'pipeline-success-no-render':
                    clearStatus('generationStatus');
                    
                    const statsNoRender = msg.result.pipelineStats;
                    const messageNoRender = `‚ö†Ô∏è Pipeline completed but no UI generated. ${statsNoRender.totalStagesWithAI} stages used AI.`;
                    showStatus('generationStatus', messageNoRender, 'warning');
                    break;

                case 'pipeline-error':
                    clearStatus('generationStatus');
                    
                    showStatus('generationStatus', `‚ùå Pipeline failed: ${msg.error}`, 'error');
                    break;

                // 3-Stage Pipeline handlers
                case '3stage-pipeline-success':
                    clearStatus('generationStatus');
                    const pipeline3Btn = document.getElementById('pipeline3Btn');
                    pipeline3Btn.disabled = false;
                    pipeline3Btn.textContent = '‚ö° 3-Stage Pipeline (NEW)';
                    
                    showStatus('generationStatus', '‚úÖ 3-Stage Pipeline completed successfully!', 'success');
                    
                    // UI was generated successfully
                    
                    document.getElementById('userPrompt').value = '';
                    break;

                case '3stage-pipeline-error':
                    clearStatus('generationStatus');
                    const pipeline3BtnError = document.getElementById('pipeline3Btn');
                    pipeline3BtnError.disabled = false;
                    pipeline3BtnError.textContent = '‚ö° 3-Stage Pipeline (NEW)';
                    
                    showStatus('generationStatus', `‚ùå 3-Stage Pipeline failed: ${msg.error}`, 'error');
                    break;

                // 3-Stage Modification Pipeline handlers

                case 'json-render-success':
                    clearStatus('generationStatus');
                    const jsonRenderBtn = document.getElementById('jsonRenderBtn');
                    jsonRenderBtn.disabled = false;
                    jsonRenderBtn.textContent = 'üé® Render JSON';
                    
                    let successMessage = `‚úÖ ${msg.result.source} JSON rendered successfully!`;
                    if (msg.result.validationWarnings && msg.result.validationWarnings.length > 0) {
                        successMessage += ` (${msg.result.validationWarnings.length} warnings auto-fixed)`;
                    }
                    showStatus('generationStatus', successMessage, 'success');
                    
                    // Hide validation feedback on success
                    document.getElementById('validation-feedback').style.display = 'none';
                    
                    // Clear input on success
                    document.getElementById('jsonInput').value = '';
                    break;

                case 'json-render-error':
                    clearStatus('generationStatus');
                    const jsonRenderBtnError = document.getElementById('jsonRenderBtn');
                    jsonRenderBtnError.disabled = false;
                    jsonRenderBtnError.textContent = 'üé® Render JSON';
                    
                    showStatus('generationStatus', `‚ùå JSON render failed: ${msg.error}`, 'error');
                    break;

                case 'validation-error':
                    clearStatus('generationStatus');
                    const jsonRenderBtnValidation = document.getElementById('jsonRenderBtn');
                    jsonRenderBtnValidation.disabled = false;
                    jsonRenderBtnValidation.textContent = 'üé® Render JSON';
                    
                    // Show validation feedback
                    const feedback = document.getElementById('validation-feedback');
                    const errorBox = document.getElementById('validation-errors');
                    const warningBox = document.getElementById('validation-warnings');
                    const errorList = document.getElementById('error-list');
                    const warningList = document.getElementById('warning-list');
                    
                    feedback.style.display = 'block';
                    
                    if (msg.errors && msg.errors.length > 0) {
                        errorBox.style.display = 'block';
                        errorList.innerHTML = msg.errors.map(e => `<li>${e}</li>`).join('');
                    } else {
                        errorBox.style.display = 'none';
                    }
                    
                    if (msg.warnings && msg.warnings.length > 0) {
                        warningBox.style.display = 'block';
                        warningList.innerHTML = msg.warnings.map(w => `<li>${w}</li>`).join('');
                    } else {
                        warningBox.style.display = 'none';
                    }
                    
                    showStatus('generationStatus', `‚ùå Validation failed: ${msg.errors ? msg.errors.length : 0} errors, ${msg.warnings ? msg.warnings.length : 0} warnings`, 'error');
                    break;


                // NEW: Session management handlers
                case 'session-found':
                    showSessionModal(msg.session);
                    break;

                case 'session-restored':
                    // Restore scan data only
                    if (msg.scanData) {
                        scanResults = msg.scanData;
                        // Store colorStyles if available in session data
                        colorStyles = msg.colorStyles || null;
                        displaySavedScan(msg.scanData);
                    }
                    
                    showStatus('generationStatus', '‚úÖ Session restored successfully!', 'success');
                    break;

                case 'session-cleared':
                    startFresh();
                    break;

                case 'all-sessions-loaded':
                    renderAllSessions(msg.sessions, msg.currentFileId);
                    break;

                case 'session-deleted':
                    // Refresh the sessions list if it's open
                    const allSessionsModal = document.getElementById('allSessionsModal');
                    if (allSessionsModal.style.display === 'flex') {
                        showAllSessions();
                    }
                    break;

                // NEW: Gemini API response handlers
                case 'connection-test-result':
                    const connectionTestBtn = document.getElementById('testBtn');
                    if (connectionTestBtn) {
                        connectionTestBtn.disabled = false;
                        connectionTestBtn.textContent = 'üîå Test Connection';
                    }
                    
                    if (msg.success) {
                        showStatus('connectionStatus', '‚úÖ Connection successful!', 'success');
                    } else {
                        showStatus('connectionStatus', `‚ùå ${msg.error || 'Connection failed'}`, 'error');
                    }
                    break;

                case 'gemini-response':
                    // Handle Gemini generation response
                    if (window.pendingGeminiRequest) {
                        if (msg.success) {
                            window.pendingGeminiRequest.resolve(msg.data);
                        } else {
                            window.pendingGeminiRequest.reject(new Error(msg.error || 'Generation failed'));
                        }
                        delete window.pendingGeminiRequest;
                    }
                    break;

                case 'api-key-save-error':
                    const apikeyErrorSaveBtn = document.getElementById('saveBtn');
                    if (apikeyErrorSaveBtn) {
                        apikeyErrorSaveBtn.disabled = false;
                        apikeyErrorSaveBtn.textContent = 'üíæ Save API Key';
                    }
                    showStatus('connectionStatus', `‚ùå Failed to save API key: ${msg.error}`, 'error');
                    break;

                case 'all-data-cleared':
                    // Refresh page after clearing all data
                    location.reload();
                    break;



                default:
                    // Ignore unknown messages
                    break;
            }
        };

        function setupImageUploadListeners() {
    const area = document.getElementById('imageUploadArea');
    const input = document.getElementById('imageInput');
    
    if (area) {
        area.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') input.click();
        });
        
        area.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            area.style.borderColor = '#0366d6';
        });
        
        area.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            area.style.borderColor = '#d1d5da';
        });
        
        area.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            area.style.borderColor = '#d1d5da';
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleImageSelection(files[0]);
            } else {
                // üîß FIX: Ensure selectedImage is null if no files dropped
                console.log('üìù No files dropped, ensuring selectedImage is null');
                selectedImage = null;
            }
        });
    }
    
    if (input) {
        input.addEventListener('change', (e) => {
            console.log('üîç File input change event fired');
            const files = e.target.files;
            console.log('üîç Files count:', files.length);
            
            if (files.length > 0) {
                console.log('üìÅ File selected:', files[0].name);
                handleImageSelection(files[0]);
            } else {
                // üîß CRITICAL FIX: When user cancels file dialog, explicitly clear selectedImage
                console.log('‚ùå File dialog canceled or no file selected, clearing selectedImage');
                selectedImage = null;
                console.log('‚úÖ selectedImage after clearing:', selectedImage);
            }
        });
        
        // üîß ADDITIONAL FIX: Listen for focus events to detect when dialog opens/closes
        input.addEventListener('focus', () => {
            console.log('üîç File input focused (dialog opening)');
        });
        
        input.addEventListener('blur', () => {
            console.log('üîç File input blurred (dialog closed)');
            // Double-check that selectedImage is properly set
            if (!input.files || input.files.length === 0) {
                console.log('üí° Dialog closed with no files, ensuring selectedImage is null');
                selectedImage = null;
            }
        });
    }
}

        // Document ready initialization
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ UI initialized');
            setupComponentListeners();
            setupApiKeyHandling();
           try {
    console.log('üîç DEBUG: About to create AIDesignerPromptGenerator');
    promptGenerator = new AIDesignerPromptGenerator();
    console.log('üîç DEBUG: Prompt generator created successfully:', !!promptGenerator);
} catch (error) {
    console.error('‚ùå ERROR creating prompt generator:', error);
}

            // Initialize DesignSystemUI
            try {
                console.log('üîç DEBUG: About to create DesignSystemUI');
                console.log('üîç DEBUG: DesignSystemUI class available:', typeof window.DesignSystemUI);
                if (window.DesignSystemUI) {
                    window.designSystemUI = new window.DesignSystemUI();
                    console.log('üîç DEBUG: DesignSystemUI instance created successfully:', !!window.designSystemUI);
                } else {
                    console.error('‚ùå DesignSystemUI class not found in window');
                }
            } catch (error) {
                console.error('‚ùå ERROR creating DesignSystemUI:', error);
            }

startFresh();
            
            // Request saved data
            parent.postMessage({ pluginMessage: { type: 'get-saved-scan' } }, '*');
            parent.postMessage({ pluginMessage: { type: 'get-api-key' } }, '*');
            
            // Ensure global functions are available (fallback if bundle doesn't load properly)
            if (typeof window.scanDesignSystem === 'undefined') {
                window.scanDesignSystem = scanDesignSystem;
                console.log('‚úÖ scanDesignSystem fallback enabled');
            }
        });
    </script>
    <script src="ui-bundle.js"></script>
</body>
</html>